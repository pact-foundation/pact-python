"""V3 Message provider feature tests."""
import base64
import json
import logging
import os
import pickle
import re
import xml.etree.ElementTree as ET
from contextlib import contextmanager
from pathlib import Path
from typing import TYPE_CHECKING

import pytest
from pytest_bdd import (
    given,
    parsers,
    scenario,
    then,
    when,
)

from pact.v3.pact import AsyncMessageInteraction, Pact
from pact.v3.verifier import Verifier

from tests.v3.compatibility_suite.util import (
    InteractionDefinition,
    parse_markdown_table,
    parse_horizontal_markdown_table,
    FIXTURES_ROOT,
)
from tests.v3.compatibility_suite.util.provider import (
    start_provider,
    the_verification_will_be_successful,
    the_verification_results_will_contain_a_error,
    the_provider_state_callback_will_be_called_before_the_verification_is_run,
    the_provider_state_callback_will_be_called_after_the_verification_is_run,
    the_provider_state_callback_will_receive_a_setup_call,
)

TEST_PACT_FILE_DIRECTORY = Path(os.path.join(os.path.dirname(__file__), 'pacts'))

logger = logging.getLogger(__name__)

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Incorrect message is generated by the provider'
)
def test_incorrect_message_is_generated_by_the_provider():
    """Incorrect message is generated by the provider."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with JSON body (negative case)'
)
def test_message_with_json_body_negative_case():
    """Message with JSON body (negative case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with JSON body (positive case)'
)
def test_message_with_json_body_positive_case():
    """Message with JSON body (positive case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with XML body (negative case)'
)
def test_message_with_xml_body_negative_case():
    """Message with XML body (negative case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with XML body (positive case)'
)
def test_message_with_xml_body_positive_case():
    """Message with XML body (positive case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with binary body (negative case)'
)
def test_message_with_binary_body_negative_case():
    """Message with binary body (negative case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with binary body (positive case)'
)
def test_message_with_binary_body_positive_case():
    """Message with binary body (positive case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with plain text body (negative case)'
)
def test_message_with_plain_text_body_negative_case():
    """Message with plain text body (negative case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Message with plain text body (positive case)'
)
def test_message_with_plain_text_body_positive_case():
    """Message with plain text body (positive case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Supports matching rules for the message body (negative case)'
)
def test_supports_matching_rules_for_the_message_body_negative_case():
    """Supports matching rules for the message body (negative case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Supports matching rules for the message body (positive case)'
)
def test_supports_matching_rules_for_the_message_body_positive_case():
    """Supports matching rules for the message body (positive case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Supports matching rules for the message metadata (negative case)'
)
def test_supports_matching_rules_for_the_message_metadata_negative_case():
    """Supports matching rules for the message metadata (negative case)."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Supports matching rules for the message metadata (positive case)'
)
def test_supports_matching_rules_for_the_message_metadata_positive_case():
    """Supports matching rules for the message metadata (positive case)."""

@pytest.mark.skip("Current unable to implement")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Supports messages with body formatted for the Kafka schema registry'
)
def test_supports_messages_with_body_formatted_for_the_kafka_schema_registry():
    """Supports messages with body formatted for the Kafka schema registry."""

#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Verifies the message metadata'
)
def test_verifies_the_message_metadata():
    """Verifies the message metadata."""


#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Verifying a simple message'
)
def test_verifying_a_simple_message():
    """Verifying a simple message."""


#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Verifying an interaction with a defined provider state'
)
def test_verifying_an_interaction_with_a_defined_provider_state():
    """Verifying an interaction with a defined provider state."""


#@pytest.mark.skip("Not implemented")
@scenario(
    'definition/features/V3/message_provider.feature',
    'Verifying multiple Pact files'
)
def test_verifying_multiple_pact_files():
    """Verifying multiple Pact files."""


################################################################################
## Given
################################################################################

@given(
    parsers.re(
        r'a Pact file for "(?P<name>[^"]+)" is to be verified with the following:\n'
        r'(?P<table>.+)',
        re.DOTALL,
    ),
    converters={"table": parse_horizontal_markdown_table},
)
def a_pact_file_for_is_to_be_verified_with_the_following(
    verifier: Verifier,
    temp_dir: Path,
    interaction_definitions: list[InteractionDefinition],
    name: str,
    table: dict[str, str],
):
    """a Pact file for "basic" is to be verified with the following:
| body           | file: basic.json                                                |
| matching rules | regex-matcher-metadata.json                                     |
| metadata       | Origin=AXP-1000; TagData=JSON: { "ID": "123", "weight": 100.5 } |."""
    metadata = {}
    if table.get('metadata'):
        metadata = dict(
            map(
                lambda z: z.replace('JSON: ', ''),
                x.split('=')
            ) for x in table['metadata'].split('; ')
        )
    pact = Pact("consumer", "provider")
    pact.with_specification("V3")
    interaction_definition = InteractionDefinition(
        method="POST",
        path=f"/{name}",
        is_async_message=True,
        metadata=metadata,
        response_body=table['body'],
        matching_rules=table.get('matching rules'),
    )
    interaction_definition.add_to_pact(pact, name, "Async")
    (temp_dir / "pacts").mkdir(exist_ok=True, parents=True)
    pact.write_file(temp_dir / "pacts")
    verifier.add_source(temp_dir / "pacts")


@given(
    parsers.parse('a Pact file for "{name}":"{fixture}" is to be verified')
)
def a_pact_file_for_is_to_be_verified(
    verifier: Verifier,
    temp_dir: Path,
    interaction_definitions: list[InteractionDefinition],
    name: str,
    fixture: str
):
    pact = Pact("consumer", "provider")
    pact.with_specification("V3")
    interaction_definition = InteractionDefinition(
        method="POST",
        path=f"/{name}",
        is_async_message=True,
        response_body=fixture,
    )
    interaction_definition.add_to_pact(pact, name, "Async")
    (temp_dir / "pacts").mkdir(exist_ok=True, parents=True)
    pact.write_file(temp_dir / "pacts")
    verifier.add_source(temp_dir / "pacts")


@given(
    parsers.parse(
        'a Pact file for "{name}":"{fixture}" is to be '
        'verified with provider state "{provider_state}"'
    )
)
def a_pact_file_for_is_to_be_verified_with_provider_state(
    temp_dir: Path,
    verifier: Verifier,
    interaction_definitions: list[InteractionDefinition],
    name: str,
    fixture: str,
    provider_state: str,
):
    """a Pact file for "basic":"file: basic.json" is to be verified with provider state "state one"."""
    pact = Pact("consumer", "provider")
    pact.with_specification("V3")
    interaction_definition = InteractionDefinition(
        method="POST",
        path=f"/{name}",
        is_async_message=True,
        response_body=fixture,
    )
    states = [InteractionDefinition.State(provider_state)]
    interaction_definition.states = states
    interaction_definition.add_to_pact(pact, name, "Async")
    (temp_dir / "pacts").mkdir(exist_ok=True, parents=True)
    pact.write_file(temp_dir / "pacts")
    verifier.add_source(temp_dir / "pacts")
    with (temp_dir / "provider_states").open("w") as f:
        logger.debug("Writing provider state to %s", temp_dir / "provider_states")
        json.dump([s.as_dict() for s in [InteractionDefinition.State(provider_state)]], f)


@given(
    parsers.re(
        r'a Pact file for "(?P<name>[^"]+)":"(?P<fixture>[^"]+)" is to be verified with the following metadata:\n'
        r'(?P<metadata>.+)',
        re.DOTALL,
    ),
    converters={"metadata": parse_markdown_table},
)
def a_pact_file_for_is_to_be_verified_with_the_following_metadata(
    temp_dir: Path,
    verifier: Verifier,
    interaction_definitions: list[InteractionDefinition],
    name: str,
    fixture: str,
    metadata: dict[str, str],
):
    """a Pact file for "basic":"file: basic.json" is to be verified with the following metadata:
| key     | value                                           |
| Origin  | Some Text                                       |
| TagData | JSON: { "ID": "100", "weight": 100.5 } |."""
    pact = Pact("consumer", "provider")
    pact.with_specification("V3")
    interaction_definition = InteractionDefinition(
        method="POST",
        path=f"/{name}",
        is_async_message=True,
        metadata={ h['key']: h['value'].replace('JSON: ', '') for h in metadata },
        response_body=fixture,
    )
    states = []
    for provider_state in provider_states:
        states.append(InteractionDefinition.State(provider_state))
    interaction_definition.states = states
    interaction_definition.add_to_pact(pact, name, "Async")
    (temp_dir / "pacts").mkdir(exist_ok=True, parents=True)
    pact.write_file(temp_dir / "pacts")
    verifier.add_source(temp_dir / "pacts")


@given(
    parsers.parse('a provider is started that can generate the "{name}" message with "{body}"'),
    target_fixture="interaction_definitions"
)
def a_provider_is_started_that_can_generate_the_message(
    temp_dir: Path,
    name: str,
    body: str,
    provider_url: str = None,
):
    interaction_definitions = []
    if ( temp_dir / "interactions.pkl").exists():
        with (temp_dir / "interactions.pkl").open("rb") as pkl_file:
            interaction_definitions = pickle.load(pkl_file)

    body = body.replace('\\"', '"')
    interaction_definition = InteractionDefinition(
        method="POST",
        path=f"/{name}",
        is_async_message=True,
        response_body=body
    )
    interaction_definitions.append(interaction_definition)
    with (temp_dir / "interactions.pkl").open("wb") as pkl_file:
        pickle.dump([interaction for interaction in interaction_definitions], pkl_file)
    return interaction_definitions


@given(
    parsers.re(
        r'a provider is started that can generate the "(?P<name>[^"]+)" '
        r'message with "(?P<fixture>[^"]+)" and the following metadata:\n'
        r'(?P<metadata>.+)',
        re.DOTALL,
    ),
    converters={"metadata": parse_markdown_table},
    target_fixture="interaction_definitions"
)
def a_provider_is_started_that_can_generate_the_message_with_the_following_metadata(
    temp_dir: Path,
    name: str,
    fixture: str,
    metadata: dict[str, str],
):
    """a provider is started that can generate the "basic" message with "file: basic.json" and the following metadata:
| key     | value                                           |
| Origin  | AAA-123                                         |
| TagData | JSON: { "ID": "123", "weight": 100.5 }          |."""
    interaction_definitions = []
    if ( temp_dir / "interactions.pkl").exists():
        with (temp_dir / "interactions.pkl").open("rb") as pkl_file:
            interaction_definitions = pickle.load(pkl_file)

    def parse_metadata_value(value):
        return json.loads(value.replace('JSON: ', '')) if value.startswith('JSON: ') else value

    interaction_definition = InteractionDefinition(
        method="POST",
        path=f"/{name}",
        is_async_message=True,
        metadata={ m['key']: parse_metadata_value(m['value']) for m in metadata },
        response_body=fixture
    )
    interaction_definitions.append(interaction_definition)
    with (temp_dir / "interactions.pkl").open("wb") as pkl_file:
        pickle.dump([interaction for interaction in interaction_definitions], pkl_file)
    return interaction_definitions


@given(
    'a provider state callback is configured',
    target_fixture="callback"
)
def a_provider_state_callback_is_configured():
    """a provider state callback is configured."""
    return True


################################################################################
## When
################################################################################


start_provider_context_manager = contextmanager(start_provider)

@when(
    "the verification is run",
    target_fixture="verifier_result",
)
def the_verification_is_run(
    verifier: Verifier,
    temp_dir: Path,
):
    """
    Run the verification.
    """

    with start_provider_context_manager(temp_dir) as provider_url:
        verifier.set_state(
            provider_url / "_test" / "callback",
            teardown=True,
        )
        verifier.set_info("provider", url=f'{provider_url}/message_handler')
        try:
            verifier.verify()
        except Exception as e:  # noqa: BLE001
            return verifier, e
        return verifier, None

################################################################################
## Then
################################################################################


the_provider_state_callback_will_be_called_before_the_verification_is_run()

the_provider_state_callback_will_be_called_after_the_verification_is_run()

the_provider_state_callback_will_receive_a_setup_call()

the_verification_will_be_successful()

the_verification_results_will_contain_a_error()
